function T(e) {
  if (!["Ascon-128", "Ascon-128a", "Ascon-80pq"].includes(e))
    throw new Error(
      `Invalid Ascon variant. "${e}" is not a valid Ascon variant out of "Ascon-128", "Ascon-128a", "Ascon-80pq".`
    );
}
function z(e) {
  if (!["Ascon-Hash", "Ascon-Hasha", "Ascon-Xof", "Ascon-Xofa"].includes(e))
    throw new Error(
      `Invalid Ascon hash variant. "${e}" is not a valid Ascon hash variant out of "Ascon-Hash", "Ascon-Hasha", "Ascon-Xof", "Ascon-Xofa".`
    );
}
function L(e, t, o) {
  if (t.length != 16)
    throw new Error(
      `Invalid nonce length. Received ${t.length} bytes but expected 16 bytes.`
    );
  if (!(e.length == 16 || e.length == 20 && o == "Ascon-80pq"))
    throw new Error(
      `Invalid key length. Received ${e.length} bytes but expected ${o == "Ascon-80pq" ? 20 : 16} bytes.`
    );
  return !0;
}
function P(e, t) {
  if (["Ascon-Hash", "Ascon-Hasha"].includes(t) && e != 32)
    throw new Error(
      `Invalid hash length. Received ${e} bytes but expected 32 bytes for ${t}.`
    );
}
function b(e) {
  return new BigInt64Array(e);
}
function m(e) {
  return new BigInt64Array(e);
}
function u(...e) {
  const t = e.reduce((s, i) => s + i.length, 0), o = new BigInt64Array(t);
  let n = 0;
  for (const s of e)
    o.set(s, n), n += s.length;
  return o;
}
function h(e) {
  return e.reduce(
    (t, o, n) => t + (BigInt(o) << BigInt((e.length - 1 - n) * 8)),
    BigInt(0)
  );
}
function d(e, t) {
  const o = [];
  for (let n = 0; n < t; n++)
    o.push(e >> BigInt((t - 1 - n) * 8) & 0xffn);
  return new BigInt64Array(o);
}
function v(e) {
  return Array(5).fill(BigInt(0)).map((t, o) => h(e.subarray(o * 8, (o + 1) * 8)));
}
function I(e, t) {
  return e >> t | (e & (1n << t) - 1n) << 64n - t;
}
function C(e, t) {
  if (e.length !== t.length)
    return !1;
  for (let o = 0; o < e.length; o++)
    if (e[o] !== t[o])
      return !1;
  return !0;
}
function B(e) {
  return e.reduce((t, o, n) => (t[n] = BigInt(o), t), new BigInt64Array(e.length));
}
function H(e) {
  return e.reduce((t, o, n) => (t[n] = Number(o), t), new Uint8Array(e.length));
}
const E = (e) => {
  if (typeof self < "u" && (self.crypto || self.msCrypto)) {
    const t = self.crypto || self.msCrypto, o = 65536, n = new Uint8Array(e);
    for (let s = 0; s < e; s += o)
      t.getRandomValues(n.subarray(s, s + Math.min(e - s, o)));
    return n;
  } else
    return require("crypto").randomBytes(e);
}, M = (e) => Array.prototype.map.call(e, (t) => t.toString(16).padStart(2, "0")).join(""), $ = (e) => Uint8Array.from(
  e.match(/.{1,2}/g)?.map((t) => parseInt(t, 16)) ?? []
);
class q {
  /**
   * Ascon hash function and extendable-output function.
   * @param message a Uint8Array of arbitrary length
   * @param options additional parameters including the variant and the length of the hash
   *
   * @returns a Uint8Array containing the hash
   *
   * @example
   * ```typescript
   * // Normal mode (Ascon-Hash)
   * const message = new TextEncoder().encode("ascon");
   * const hash = Ascon.hash(message);
   * hash // 32 bytes hash
   *
   * // XOF mode (Ascon-Xof)
   * const message = new TextEncoder().encode("ascon");
   * const hash = Ascon.hash(message, { variant: "Ascon-Xof", length: 64 });
   * hash // 64 bytes hash (default is 32 bytes)
   * ```
   */
  static hash(t, o) {
    const n = B(t), s = o?.variant ?? "Ascon-Hash", i = o?.length ?? 32;
    z(s), P(i, s);
    const c = 12, r = ["Ascon-Hasha", "Ascon-Xofa"].includes(s) ? 8 : 12, l = 8, a = d(
      ["Ascon-Hash", "Ascon-Hasha"].includes(s) ? 256n : 0n,
      4
    ), f = v(
      u(
        b([0n, BigInt(l * 8), BigInt(c), BigInt(c - r)]),
        a,
        m(32)
      )
    );
    this.permutation(f, c);
    const g = u(
      n,
      b([0x80n]),
      m(l - n.length % l - 1)
    );
    for (let p = 0; p < g.length - l; p += l)
      f[0] ^= h(g.slice(p, p + 8)), this.permutation(f, r);
    const y = g.length - l;
    f[0] ^= h(g.slice(y, y + 8)), this.permutation(f, c);
    let A = new BigInt64Array();
    for (; A.length < i; )
      A = u(A, d(f[0], 8)), this.permutation(f, r);
    return H(A.slice(0, i));
  }
  /**
   * Ascon encryption.
   * @param key a Uint8Array of size 16 (for Ascon-128, Ascon-128a; 128-bit security) or 20 (for Ascon-80pq; 128-bit security)
   * @param nonce a Uint8Array of size 16 (must not repeat for the same key!)
   * @param plaintext a Uint8Array of arbitrary length
   * @param options additional parameters including the variant and associated data as a Uint8Array
   *
   * @returns a Uint8Array of length plaintext.length + 16 containing the ciphertext and tag
   *
   * @example
   * ```typescript
   * const key = new Uint8Array([...]);
   * const nonce = new Uint8Array([...]);
   * const plaintext = new TextEncoder().encode("ascon");
   *
   * const ciphertext = Ascon.encrypt(key, nonce, plaintext);
   *
   * // With associated data
   * const key = new Uint8Array([...]);
   * const nonce = new Uint8Array([...]);
   * const plaintext = new TextEncoder().encode("ascon");
   * const associatedData = new TextEncoder().encode("more data");
   *
   * const ciphertext = Ascon.encrypt(key, nonce, plaintext, { associatedData });
   * ```
   */
  static encrypt(t, o, n, s) {
    const i = B(t), c = B(o), r = B(n), l = s?.associatedData ? B(s?.associatedData) : void 0, a = s?.variant ?? "Ascon-128";
    T(a), L(i, c, a);
    let f = Array(5).fill(BigInt(0));
    const g = i.length * 8, y = 12, A = a === "Ascon-128a" ? 8 : 6, p = a === "Ascon-128a" ? 16 : 8;
    f = this.initialize(f, g, p, y, A, i, c), this.processAssociatedData(f, A, p, l);
    const x = this.processPlaintext(f, A, p, r), w = this.finalize(f, p, y, i);
    return H(u(x, w));
  }
  /**
   * Ascon decryption.
   * @param key a Uint8Array of size 16 (for Ascon-128, Ascon-128a; 128-bit security) or 20 (for Ascon-80pq; 128-bit security)
   * @param nonce a Uint8Array of size 16 (must not repeat for the same key!)
   * @param ciphertext a Uint8Array of arbitrary length
   * @param options additional parameters including the variant and associated data as a Uint8Array
   *
   * @returns a Uint8Array containing the plaintext or throws when the verification fails
   * @throws when the verification fails
   *
   * @example
   * ```typescript
   * const key = new Uint8Array([...]);
   * const nonce = new Uint8Array([...]);
   * const ciphertext = new Uint8Array([...]);
   *
   * const plaintext = Ascon.decrypt(key, nonce, ciphertext);
   * plaintext // "ascon"
   *
   * // With associated data
   * const key = new Uint8Array([...]);
   * const nonce = new Uint8Array([...]);
   * const ciphertext = new Uint8Array([...]);
   * const associatedData = new TextEncoder().encode("more data");
   *
   * const plaintext = Ascon.decrypt(key, nonce, ciphertext, { associatedData });
   * plaintext // "ascon"
   *
   * ```
   */
  static decrypt(t, o, n, s) {
    const i = B(t), c = B(o), r = B(n), l = s?.associatedData ? B(s?.associatedData) : void 0, a = s?.variant ?? "Ascon-128";
    if (T(a), L(i, c, a), n.length < 16)
      throw new Error("Could not be decrypted. Ciphertext too short.");
    let f = Array(5).fill(BigInt(0));
    const g = i.length * 8, y = 12, A = a === "Ascon-128a" ? 8 : 6, p = a === "Ascon-128a" ? 16 : 8;
    f = this.initialize(f, g, p, y, A, i, c), this.processAssociatedData(f, A, p, l);
    const x = this.processCipherText(
      f,
      A,
      p,
      r.slice(0, -16)
    ), w = this.finalize(f, p, y, i);
    if (!C(w, r.slice(-16)))
      throw new Error("Could not be decrypted. Tags don't match.");
    return H(x);
  }
  static initialize(t, o, n, s, i, c, r) {
    const l = u(
      b([
        BigInt(o),
        BigInt(n * 8),
        BigInt(s),
        BigInt(i),
        ...new Array(20 - c.length).fill(0n)
      ]),
      c,
      r
    );
    t = t.map((f, g) => v(l)[g]), this.permutation(t, s);
    const a = v(u(m(40 - c.length), c));
    return t = t.map((f, g) => f ^ a[g]), t;
  }
  static processAssociatedData(t, o, n, s) {
    if (s && s.length > 0) {
      const i = n - s.length % n - 1, c = u(
        s,
        b([0x80n]),
        m(Number(i))
      );
      for (let r = 0; r < c.length; r += Number(n))
        t[0] ^= h(c.slice(r, r + 8)), n === 16 && (t[1] ^= h(c.slice(r + 8, r + 16))), this.permutation(t, o);
    }
    t[4] ^= 1n;
  }
  static processPlaintext(t, o, n, s) {
    const i = s.length % n, c = u(
      s,
      b([0x80n]),
      m(n - i - 1)
    );
    let r = new BigInt64Array();
    for (let a = 0; a < c.length - n; a += n)
      n === 8 ? (t[0] ^= h(c.slice(a, a + 8)), r = u(r, d(t[0], 8))) : n === 16 && (t[0] ^= h(c.slice(a, a + 8)), t[1] ^= h(c.slice(a + 8, a + 16)), r = u(
        r,
        d(t[0], 8),
        d(t[1], 8)
      )), this.permutation(t, o);
    const l = c.length - n;
    return n === 8 ? (t[0] ^= h(c.slice(l, l + 8)), r = u(
      r,
      d(t[0], 8).slice(0, i)
    )) : n === 16 && (t[0] ^= h(c.slice(l, l + 8)), t[1] ^= h(c.slice(l + 8, l + 16)), r = u(
      r,
      d(t[0], 8).slice(0, Math.min(8, i)),
      d(t[1], 8).slice(0, Math.max(0, i - 8))
    )), r;
  }
  static processCipherText(t, o, n, s) {
    const i = s.length % n, c = u(s, m(n - i));
    let r = new BigInt64Array();
    for (let a = 0; a < c.length - n; a += n) {
      if (n === 8) {
        const f = h(c.slice(a, a + 8));
        r = u(r, d(t[0] ^ f, 8)), t[0] = f;
      } else if (n === 16) {
        const f = h(c.slice(a, a + 8)), g = h(c.slice(a + 8, a + 16));
        r = u(
          r,
          d(t[0] ^ f, 8),
          d(t[1] ^ g, 8)
        ), t[0] = f, t[1] = g;
      }
      this.permutation(t, o);
    }
    const l = c.length - n;
    if (n === 8) {
      const a = 0x80n << BigInt(n - i - 1) * 8n, f = 0xffffffffffffffffn >> BigInt(i * 8), g = h(c.slice(l, l + 8));
      r = u(
        r,
        d(g ^ t[0], 8).slice(0, i)
      ), t[0] = g ^ t[0] & f ^ a;
    } else if (n === 16) {
      const a = BigInt(i % 8), f = 0x80n << (8n - a - 1n) * 8n, g = 0xffffffffffffffffn >> a * 8n, y = h(c.slice(l, l + 8)), A = h(c.slice(l + 8, l + 16));
      r = u(
        r,
        u(d(t[0] ^ y, 8), d(t[1] ^ A, 8)).slice(
          0,
          i
        )
      ), i < 8 ? t[0] = y ^ t[0] & g ^ f : (t[0] = y, t[1] = A ^ t[1] & g ^ f);
    }
    return r;
  }
  static finalize(t, o, n, s) {
    const i = o;
    t[Math.floor(i / 8) + 0] ^= h(s.slice(0, 8)), t[Math.floor(i / 8) + 1] ^= h(s.slice(8, 16));
    const c = u(s, m(24 - s.length));
    return t[Math.floor(i / 8) + 2] ^= h(c.slice(16)), this.permutation(t, n), t[3] ^= h(s.slice(-16, -8)), t[4] ^= h(s.slice(-8)), u(d(t[3], 8), d(t[4], 8));
  }
  static permutation(t, o = 1) {
    for (let n = 12 - o; n < 12; n++) {
      t[2] ^= 0xf0n - BigInt(n) * 0x10n + BigInt(n) * 0x1n, t[0] ^= t[4], t[4] ^= t[3], t[2] ^= t[1];
      const s = [];
      for (let i = 0; i < 5; i++)
        s.push((t[i] ^ 0xffffffffffffffffn) & t[(i + 1) % 5]);
      for (let i = 0; i < 5; i++)
        t[i] ^= s[(i + 1) % 5];
      t[1] ^= t[0], t[0] ^= t[4], t[3] ^= t[2], t[2] ^= 0xffffffffffffffffn, t[0] ^= I(t[0], 19n) ^ I(t[0], 28n), t[1] ^= I(t[1], 61n) ^ I(t[1], 39n), t[2] ^= I(t[2], 1n) ^ I(t[2], 6n), t[3] ^= I(t[3], 10n) ^ I(t[3], 17n), t[4] ^= I(t[4], 7n) ^ I(t[4], 41n);
    }
  }
}
export {
  q as Ascon,
  $ as fromHex,
  E as randomBytes,
  M as toHex
};
//# sourceMappingURL=ascon-js.mjs.map
