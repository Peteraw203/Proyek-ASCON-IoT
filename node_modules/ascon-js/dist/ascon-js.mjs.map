{"version":3,"file":"ascon-js.mjs","sources":["../src/helper.ts","../src/ascon.ts"],"sourcesContent":["import type {\n  AsconEncryptionVariant,\n  AsconHashVariant,\n  BytesLike,\n} from \"./interfaces\";\n\n/**\n * Assert that the variant is a valid Ascon variant.\n * @param variant The variant to assert.\n */\nexport function assertVariant(\n  variant: string\n): asserts variant is AsconEncryptionVariant {\n  if (![\"Ascon-128\", \"Ascon-128a\", \"Ascon-80pq\"].includes(variant)) {\n    throw new Error(\n      `Invalid Ascon variant. \"${variant}\" is not a valid Ascon variant out of \"Ascon-128\", \"Ascon-128a\", \"Ascon-80pq\".`\n    );\n  }\n}\n\nexport function assertHashVariant(\n  variant: string\n): asserts variant is AsconHashVariant {\n  if (\n    ![\"Ascon-Hash\", \"Ascon-Hasha\", \"Ascon-Xof\", \"Ascon-Xofa\"].includes(variant)\n  ) {\n    throw new Error(\n      `Invalid Ascon hash variant. \"${variant}\" is not a valid Ascon hash variant out of \"Ascon-Hash\", \"Ascon-Hasha\", \"Ascon-Xof\", \"Ascon-Xofa\".`\n    );\n  }\n}\n\n/**\n * Assert that the key and nonce are of the correct length.\n * @param key The key to assert.\n * @param nonce The nonce to assert.\n * @param variant The used variant.\n */\nexport function assertLength(\n  key: BytesLike,\n  nonce: BytesLike,\n  variant: AsconEncryptionVariant\n) {\n  // Check the correct nonce length.\n  if (nonce.length != 16) {\n    throw new Error(\n      `Invalid nonce length. Received ${nonce.length} bytes but expected 16 bytes.`\n    );\n  }\n\n  // Check the correct key length.\n  if (!(key.length == 16 || (key.length == 20 && variant == \"Ascon-80pq\"))) {\n    throw new Error(\n      `Invalid key length. Received ${key.length} bytes but expected ${\n        variant == \"Ascon-80pq\" ? 20 : 16\n      } bytes.`\n    );\n  }\n\n  return true;\n}\n\nexport function assertHashLength(\n  hashLength: number,\n  variant: AsconHashVariant\n) {\n  if ([\"Ascon-Hash\", \"Ascon-Hasha\"].includes(variant) && hashLength != 32) {\n    throw new Error(\n      `Invalid hash length. Received ${hashLength} bytes but expected 32 bytes for ${variant}.`\n    );\n  }\n  // else if ([\"Ascon-Xof\", \"Ascon-Xofa\"].includes(variant) && hashLength < 32) {\n  //   throw new Error(\n  //     `Invalid hash length. Received ${hashLength} bytes but expected >= 32 bytes.`\n  //   );\n  // }\n}\n\nexport function toBytes(value: bigint[]): BytesLike {\n  return new BigInt64Array(value);\n}\n\nexport function zeroBytes(length: number): BytesLike {\n  return new BigInt64Array(length);\n}\n\nexport function concatArrays(...arrays: BytesLike[]): BytesLike {\n  const totalLength = arrays.reduce((acc, val) => acc + val.length, 0);\n  const result = new BigInt64Array(totalLength);\n  let offset = 0;\n\n  for (const array of arrays) {\n    result.set(array, offset);\n    offset += array.length;\n  }\n\n  return result;\n}\n\nexport function bytesToInt(bytes: BytesLike): bigint {\n  return bytes.reduce(\n    (acc, bi, i) => acc + (BigInt(bi) << BigInt((bytes.length - 1 - i) * 8)),\n    BigInt(0)\n  );\n}\n\nexport function intToBytes(integer: bigint, nBytes: number): BytesLike {\n  const result: bigint[] = [];\n  for (let i = 0; i < nBytes; i++) {\n    result.push((integer >> BigInt((nBytes - 1 - i) * 8)) & 0xffn);\n  }\n  return new BigInt64Array(result);\n}\n\nexport function bytesToState(bytes: BytesLike): bigint[] {\n  return Array(5)\n    .fill(BigInt(0))\n    .map((_, w) => bytesToInt(bytes.subarray(w * 8, (w + 1) * 8)));\n}\n\nexport function rotr(val: bigint, r: bigint): bigint {\n  return (val >> r) | ((val & ((1n << r) - 1n)) << (64n - r));\n}\n\nexport function arrayEquals(a: BytesLike, b: BytesLike): boolean {\n  if (a.length !== b.length) return false;\n  for (let i = 0; i < a.length; i++) {\n    if (a[i] !== b[i]) return false;\n  }\n  return true;\n}\n\nexport function transformArrayBufferToBigInt(array: Uint8Array): BytesLike {\n  return array.reduce((acc, val, i) => {\n    acc[i] = BigInt(val);\n    return acc;\n  }, new BigInt64Array(array.length));\n}\n\nexport function transformBigIntToArrayBufferLike(array: BytesLike): Uint8Array {\n  return array.reduce((acc, val, i) => {\n    acc[i] = Number(val);\n    return acc;\n  }, new Uint8Array(array.length));\n}\n\nexport const randomBytes = (n: number): Uint8Array => {\n  // @ts-ignore\n  if (typeof self !== \"undefined\" && (self.crypto || self.msCrypto)) {\n    // Browsers\n    // @ts-ignore\n    const crypto = self.crypto || self.msCrypto;\n    const QUOTA = 65536;\n    const a = new Uint8Array(n);\n    for (let i = 0; i < n; i += QUOTA) {\n      crypto.getRandomValues(a.subarray(i, i + Math.min(n - i, QUOTA)));\n    }\n    return a;\n  } else {\n    // Node\n    return require(\"crypto\").randomBytes(n);\n  }\n};\n\n/**\n * Convert a buffer to a hex string.\n * @param buffer The buffer to convert.\n * @returns The hex string.\n */\nexport const toHex = (buffer: Uint8Array): string => {\n  return Array.prototype.map\n    .call(buffer, (n) => n.toString(16).padStart(2, \"0\"))\n    .join(\"\");\n};\n\n/**\n * Convert a hex string to a buffer.\n * @param hexString The hex string to convert.\n * @returns The buffer.\n */\nexport const fromHex = (hexString: string) => {\n  return Uint8Array.from(\n    hexString.match(/.{1,2}/g)?.map((byte) => parseInt(byte, 16)) ?? []\n  );\n};\n","import {\n  arrayEquals,\n  assertHashLength,\n  assertHashVariant,\n  assertLength,\n  assertVariant,\n  bytesToInt,\n  bytesToState,\n  concatArrays,\n  intToBytes,\n  rotr,\n  toBytes,\n  transformArrayBufferToBigInt,\n  transformBigIntToArrayBufferLike,\n  zeroBytes,\n} from \"./helper\";\nimport type {\n  AsconEncryptionOptions,\n  AsconHashOptions,\n  BytesLike,\n} from \"./interfaces\";\n\nexport class Ascon {\n  /**\n   * Ascon hash function and extendable-output function.\n   * @param message a Uint8Array of arbitrary length\n   * @param options additional parameters including the variant and the length of the hash\n   *\n   * @returns a Uint8Array containing the hash\n   *\n   * @example\n   * ```typescript\n   * // Normal mode (Ascon-Hash)\n   * const message = new TextEncoder().encode(\"ascon\");\n   * const hash = Ascon.hash(message);\n   * hash // 32 bytes hash\n   *\n   * // XOF mode (Ascon-Xof)\n   * const message = new TextEncoder().encode(\"ascon\");\n   * const hash = Ascon.hash(message, { variant: \"Ascon-Xof\", length: 64 });\n   * hash // 64 bytes hash (default is 32 bytes)\n   * ```\n   */\n  public static hash(\n    message: Uint8Array,\n    options?: AsconHashOptions\n  ): Uint8Array {\n    const bigArray = transformArrayBufferToBigInt(message);\n\n    const variant = options?.variant ?? \"Ascon-Hash\";\n    const hashLength = (options as { length?: number })?.length ?? 32;\n\n    assertHashVariant(variant);\n    assertHashLength(hashLength, variant);\n\n    const a = 12; // rounds\n    const b = [\"Ascon-Hasha\", \"Ascon-Xofa\"].includes(variant) ? 8 : 12;\n    const rate = 8; // bytes\n\n    const tagSpec = intToBytes(\n      [\"Ascon-Hash\", \"Ascon-Hasha\"].includes(variant) ? 256n : 0n,\n      4\n    );\n\n    const S = bytesToState(\n      concatArrays(\n        toBytes([0n, BigInt(rate * 8), BigInt(a), BigInt(a - b)]),\n        tagSpec,\n        zeroBytes(32)\n      )\n    );\n\n    this.permutation(S, a);\n\n    const mPadded = concatArrays(\n      bigArray,\n      toBytes([0x80n]),\n      zeroBytes(rate - (bigArray.length % rate) - 1)\n    );\n\n    // first s - 1 blocks\n    for (let i = 0; i < mPadded.length - rate; i += rate) {\n      S[0] ^= bytesToInt(mPadded.slice(i, i + 8)); // rate = 8\n      this.permutation(S, b);\n    }\n\n    const i = mPadded.length - rate;\n    S[0] ^= bytesToInt(mPadded.slice(i, i + 8)); // rate = 8\n\n    this.permutation(S, a);\n\n    let hash = new BigInt64Array();\n    while (hash.length < hashLength) {\n      hash = concatArrays(hash, intToBytes(S[0], 8)); // rate = 8\n      this.permutation(S, b);\n    }\n\n    return transformBigIntToArrayBufferLike(hash.slice(0, hashLength));\n  }\n\n  /**\n   * Ascon encryption.\n   * @param key a Uint8Array of size 16 (for Ascon-128, Ascon-128a; 128-bit security) or 20 (for Ascon-80pq; 128-bit security)\n   * @param nonce a Uint8Array of size 16 (must not repeat for the same key!)\n   * @param plaintext a Uint8Array of arbitrary length\n   * @param options additional parameters including the variant and associated data as a Uint8Array\n   *\n   * @returns a Uint8Array of length plaintext.length + 16 containing the ciphertext and tag\n   *\n   * @example\n   * ```typescript\n   * const key = new Uint8Array([...]);\n   * const nonce = new Uint8Array([...]);\n   * const plaintext = new TextEncoder().encode(\"ascon\");\n   *\n   * const ciphertext = Ascon.encrypt(key, nonce, plaintext);\n   *\n   * // With associated data\n   * const key = new Uint8Array([...]);\n   * const nonce = new Uint8Array([...]);\n   * const plaintext = new TextEncoder().encode(\"ascon\");\n   * const associatedData = new TextEncoder().encode(\"more data\");\n   *\n   * const ciphertext = Ascon.encrypt(key, nonce, plaintext, { associatedData });\n   * ```\n   */\n  public static encrypt(\n    key: Uint8Array,\n    nonce: Uint8Array,\n    plaintext: Uint8Array,\n    options?: AsconEncryptionOptions\n  ): Uint8Array {\n    const bigKey = transformArrayBufferToBigInt(key);\n    const bigNonce = transformArrayBufferToBigInt(nonce);\n    const bigPlaintext = transformArrayBufferToBigInt(plaintext);\n    const bigAssociatedData = options?.associatedData\n      ? transformArrayBufferToBigInt(options?.associatedData)\n      : undefined;\n\n    const variant = options?.variant ?? \"Ascon-128\";\n    assertVariant(variant);\n    assertLength(bigKey, bigNonce, variant);\n\n    let S = Array(5).fill(BigInt(0));\n    const k = bigKey.length * 8; // bits\n    const a = 12; // rounds\n    const b = variant === \"Ascon-128a\" ? 8 : 6; // rounds\n    const rate = variant === \"Ascon-128a\" ? 16 : 8; // bytes\n\n    S = this.initialize(S, k, rate, a, b, bigKey, bigNonce);\n    this.processAssociatedData(S, b, rate, bigAssociatedData);\n\n    const cipherText = this.processPlaintext(S, b, rate, bigPlaintext);\n    const tag = this.finalize(S, rate, a, bigKey);\n\n    return transformBigIntToArrayBufferLike(concatArrays(cipherText, tag));\n  }\n\n  /**\n   * Ascon decryption.\n   * @param key a Uint8Array of size 16 (for Ascon-128, Ascon-128a; 128-bit security) or 20 (for Ascon-80pq; 128-bit security)\n   * @param nonce a Uint8Array of size 16 (must not repeat for the same key!)\n   * @param ciphertext a Uint8Array of arbitrary length\n   * @param options additional parameters including the variant and associated data as a Uint8Array\n   *\n   * @returns a Uint8Array containing the plaintext or throws when the verification fails\n   * @throws when the verification fails\n   *\n   * @example\n   * ```typescript\n   * const key = new Uint8Array([...]);\n   * const nonce = new Uint8Array([...]);\n   * const ciphertext = new Uint8Array([...]);\n   *\n   * const plaintext = Ascon.decrypt(key, nonce, ciphertext);\n   * plaintext // \"ascon\"\n   *\n   * // With associated data\n   * const key = new Uint8Array([...]);\n   * const nonce = new Uint8Array([...]);\n   * const ciphertext = new Uint8Array([...]);\n   * const associatedData = new TextEncoder().encode(\"more data\");\n   *\n   * const plaintext = Ascon.decrypt(key, nonce, ciphertext, { associatedData });\n   * plaintext // \"ascon\"\n   *\n   * ```\n   */\n  public static decrypt(\n    key: Uint8Array,\n    nonce: Uint8Array,\n    ciphertext: Uint8Array,\n    options?: AsconEncryptionOptions\n  ): Uint8Array {\n    const bigKey = transformArrayBufferToBigInt(key);\n    const bigNonce = transformArrayBufferToBigInt(nonce);\n    const bigCiphertext = transformArrayBufferToBigInt(ciphertext);\n    const bigAssociatedData = options?.associatedData\n      ? transformArrayBufferToBigInt(options?.associatedData)\n      : undefined;\n\n    const variant = options?.variant ?? \"Ascon-128\";\n\n    assertVariant(variant);\n    assertLength(bigKey, bigNonce, variant);\n\n    if (ciphertext.length < 16) {\n      throw new Error(\"Could not be decrypted. Ciphertext too short.\");\n    }\n\n    let S = Array(5).fill(BigInt(0));\n    const k = bigKey.length * 8; // bits\n    const a = 12; // rounds\n    const b = variant === \"Ascon-128a\" ? 8 : 6; // rounds\n    const rate = variant === \"Ascon-128a\" ? 16 : 8; // bytes\n\n    S = this.initialize(S, k, rate, a, b, bigKey, bigNonce);\n    this.processAssociatedData(S, b, rate, bigAssociatedData);\n\n    const plainText = this.processCipherText(\n      S,\n      b,\n      rate,\n      bigCiphertext.slice(0, -16)\n    );\n\n    const tag = this.finalize(S, rate, a, bigKey);\n\n    if (!arrayEquals(tag, bigCiphertext.slice(-16))) {\n      throw new Error(\"Could not be decrypted. Tags don't match.\");\n    }\n\n    return transformBigIntToArrayBufferLike(plainText);\n  }\n\n  private static initialize(\n    S: bigint[],\n    k: number,\n    rate: number,\n    a: number,\n    b: number,\n    key: BytesLike,\n    nonce: BytesLike\n  ) {\n    const iv_zero_key_nonce = concatArrays(\n      toBytes([\n        BigInt(k),\n        BigInt(rate * 8),\n        BigInt(a),\n        BigInt(b),\n        ...new Array(20 - key.length).fill(0n),\n      ]),\n      key,\n      nonce\n    );\n\n    S = S.map((_, i) => bytesToState(iv_zero_key_nonce)[i]);\n\n    // Permute the state.\n    this.permutation(S, a);\n\n    const zeroKey = bytesToState(concatArrays(zeroBytes(40 - key.length), key));\n\n    // Apply the zeroKey to the state.\n    S = S.map((s, i) => s ^ zeroKey[i]);\n\n    return S;\n  }\n\n  private static processAssociatedData(\n    S: bigint[],\n    b: number,\n    rate: number,\n    associatedData: BytesLike | undefined\n  ) {\n    if (associatedData && associatedData.length > 0) {\n      const aZeros = rate - (associatedData.length % rate) - 1;\n      const aPadded = concatArrays(\n        associatedData,\n        toBytes([0x80n]),\n        zeroBytes(Number(aZeros))\n      );\n\n      for (let i = 0; i < aPadded.length; i += Number(rate)) {\n        S[0] ^= bytesToInt(aPadded.slice(i, i + 8));\n        if (rate === 16) {\n          S[1] ^= bytesToInt(aPadded.slice(i + 8, i + 16));\n        }\n\n        this.permutation(S, b);\n      }\n    }\n\n    S[4] ^= 1n;\n  }\n\n  private static processPlaintext(\n    S: bigint[],\n    b: number,\n    rate: number,\n    plaintext: BytesLike\n  ): BytesLike {\n    const pLastLen = plaintext.length % rate;\n    const pPadded = concatArrays(\n      plaintext,\n      toBytes([0x80n]),\n      zeroBytes(rate - pLastLen - 1)\n    );\n\n    let ciphertext = new BigInt64Array();\n    for (let i = 0; i < pPadded.length - rate; i += rate) {\n      if (rate === 8) {\n        S[0] ^= bytesToInt(pPadded.slice(i, i + 8));\n\n        ciphertext = concatArrays(ciphertext, intToBytes(S[0], 8));\n      } else if (rate === 16) {\n        S[0] ^= bytesToInt(pPadded.slice(i, i + 8));\n        S[1] ^= bytesToInt(pPadded.slice(i + 8, i + 16));\n\n        ciphertext = concatArrays(\n          ciphertext,\n          intToBytes(S[0], 8),\n          intToBytes(S[1], 8)\n        );\n      }\n\n      this.permutation(S, b);\n    }\n\n    // last block t\n    const i = pPadded.length - rate;\n    if (rate === 8) {\n      S[0] ^= bytesToInt(pPadded.slice(i, i + 8));\n\n      ciphertext = concatArrays(\n        ciphertext,\n        intToBytes(S[0], 8).slice(0, pLastLen)\n      );\n    } else if (rate === 16) {\n      S[0] ^= bytesToInt(pPadded.slice(i, i + 8));\n      S[1] ^= bytesToInt(pPadded.slice(i + 8, i + 16));\n\n      ciphertext = concatArrays(\n        ciphertext,\n        intToBytes(S[0], 8).slice(0, Math.min(8, pLastLen)),\n        intToBytes(S[1], 8).slice(0, Math.max(0, pLastLen - 8))\n      );\n    }\n\n    return ciphertext;\n  }\n\n  private static processCipherText(\n    S: bigint[],\n    b: number,\n    rate: number,\n    ciphertext: BytesLike\n  ) {\n    const cLastLen = ciphertext.length % rate;\n    const cPadded = concatArrays(ciphertext, zeroBytes(rate - cLastLen));\n\n    let plaintext = new BigInt64Array();\n    for (let i = 0; i < cPadded.length - rate; i += rate) {\n      if (rate === 8) {\n        const c = bytesToInt(cPadded.slice(i, i + 8));\n\n        plaintext = concatArrays(plaintext, intToBytes(S[0] ^ c, 8));\n\n        S[0] = c;\n      } else if (rate === 16) {\n        const c0 = bytesToInt(cPadded.slice(i, i + 8));\n        const c1 = bytesToInt(cPadded.slice(i + 8, i + 16));\n\n        plaintext = concatArrays(\n          plaintext,\n          intToBytes(S[0] ^ c0, 8),\n          intToBytes(S[1] ^ c1, 8)\n        );\n\n        S[0] = c0;\n        S[1] = c1;\n      }\n\n      this.permutation(S, b);\n    }\n\n    // last block t\n    const i = cPadded.length - rate;\n    if (rate === 8) {\n      const cPadding = 0x80n << (BigInt(rate - cLastLen - 1) * 8n);\n      const cMask = 0xffffffffffffffffn >> BigInt(cLastLen * 8);\n      const c = bytesToInt(cPadded.slice(i, i + 8));\n\n      plaintext = concatArrays(\n        plaintext,\n        intToBytes(c ^ S[0], 8).slice(0, cLastLen)\n      );\n      S[0] = c ^ (S[0] & cMask) ^ cPadding;\n    } else if (rate === 16) {\n      const cLastLenWord = BigInt(cLastLen % 8);\n      const cPadding = 0x80n << ((8n - cLastLenWord - 1n) * 8n);\n      const cMask = 0xffffffffffffffffn >> (cLastLenWord * 8n);\n      const c0 = bytesToInt(cPadded.slice(i, i + 8));\n      const c1 = bytesToInt(cPadded.slice(i + 8, i + 16));\n\n      plaintext = concatArrays(\n        plaintext,\n        concatArrays(intToBytes(S[0] ^ c0, 8), intToBytes(S[1] ^ c1, 8)).slice(\n          0,\n          cLastLen\n        )\n      );\n\n      if (cLastLen < 8) {\n        S[0] = c0 ^ (S[0] & cMask) ^ cPadding;\n      } else {\n        S[0] = c0;\n        S[1] = c1 ^ (S[1] & cMask) ^ cPadding;\n      }\n    }\n\n    return plaintext;\n  }\n\n  private static finalize(\n    S: bigint[],\n    rate: number,\n    a: number,\n    key: BytesLike\n  ) {\n    const numRate = rate;\n    S[Math.floor(numRate / 8) + 0] ^= bytesToInt(key.slice(0, 8));\n    S[Math.floor(numRate / 8) + 1] ^= bytesToInt(key.slice(8, 16));\n    const pKey = concatArrays(key, zeroBytes(24 - key.length));\n    S[Math.floor(numRate / 8) + 2] ^= bytesToInt(pKey.slice(16));\n\n    this.permutation(S, a);\n\n    S[3] ^= bytesToInt(key.slice(-16, -8));\n    S[4] ^= bytesToInt(key.slice(-8));\n\n    return concatArrays(intToBytes(S[3], 8), intToBytes(S[4], 8));\n  }\n\n  private static permutation(S: bigint[], rounds = 1) {\n    for (let r = 12 - rounds; r < 12; r++) {\n      // add round constants\n      S[2] ^= 0xf0n - BigInt(r) * 0x10n + BigInt(r) * 0x1n;\n\n      // substitution layer\n      S[0] ^= S[4];\n      S[4] ^= S[3];\n      S[2] ^= S[1];\n      const T: bigint[] = [];\n      for (let i = 0; i < 5; i++) {\n        T.push((S[i] ^ 0xffffffffffffffffn) & S[(i + 1) % 5]);\n      }\n      for (let i = 0; i < 5; i++) {\n        S[i] ^= T[(i + 1) % 5];\n      }\n      S[1] ^= S[0];\n      S[0] ^= S[4];\n      S[3] ^= S[2];\n      S[2] ^= 0xffffffffffffffffn;\n\n      // linear diffusion layer\n      S[0] ^= rotr(S[0], 19n) ^ rotr(S[0], 28n);\n      S[1] ^= rotr(S[1], 61n) ^ rotr(S[1], 39n);\n      S[2] ^= rotr(S[2], 1n) ^ rotr(S[2], 6n);\n      S[3] ^= rotr(S[3], 10n) ^ rotr(S[3], 17n);\n      S[4] ^= rotr(S[4], 7n) ^ rotr(S[4], 41n);\n    }\n  }\n}\n"],"names":["assertVariant","variant","assertHashVariant","assertLength","key","nonce","assertHashLength","hashLength","toBytes","value","zeroBytes","length","concatArrays","arrays","totalLength","acc","val","result","offset","array","bytesToInt","bytes","bi","i","intToBytes","integer","nBytes","bytesToState","_","w","rotr","r","arrayEquals","a","b","transformArrayBufferToBigInt","transformBigIntToArrayBufferLike","randomBytes","n","crypto","QUOTA","toHex","buffer","fromHex","hexString","byte","Ascon","message","options","bigArray","rate","tagSpec","S","mPadded","hash","plaintext","bigKey","bigNonce","bigPlaintext","bigAssociatedData","k","cipherText","tag","ciphertext","bigCiphertext","plainText","iv_zero_key_nonce","zeroKey","s","associatedData","aZeros","aPadded","pLastLen","pPadded","cLastLen","cPadded","c","c0","c1","cPadding","cMask","cLastLenWord","numRate","pKey","rounds","T"],"mappings":"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"}