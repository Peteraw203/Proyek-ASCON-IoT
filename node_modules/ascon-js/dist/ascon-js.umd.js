(function(B,x){typeof exports=="object"&&typeof module<"u"?x(exports):typeof define=="function"&&define.amd?define(["exports"],x):(B=typeof globalThis<"u"?globalThis:B||self,x(B.AsconJS={}))})(this,function(B){"use strict";function x(e){if(!["Ascon-128","Ascon-128a","Ascon-80pq"].includes(e))throw new Error(`Invalid Ascon variant. "${e}" is not a valid Ascon variant out of "Ascon-128", "Ascon-128a", "Ascon-80pq".`)}function z(e){if(!["Ascon-Hash","Ascon-Hasha","Ascon-Xof","Ascon-Xofa"].includes(e))throw new Error(`Invalid Ascon hash variant. "${e}" is not a valid Ascon hash variant out of "Ascon-Hash", "Ascon-Hasha", "Ascon-Xof", "Ascon-Xofa".`)}function P(e,t,o){if(t.length!=16)throw new Error(`Invalid nonce length. Received ${t.length} bytes but expected 16 bytes.`);if(!(e.length==16||e.length==20&&o=="Ascon-80pq"))throw new Error(`Invalid key length. Received ${e.length} bytes but expected ${o=="Ascon-80pq"?20:16} bytes.`);return!0}function M(e,t){if(["Ascon-Hash","Ascon-Hasha"].includes(t)&&e!=32)throw new Error(`Invalid hash length. Received ${e} bytes but expected 32 bytes for ${t}.`)}function w(e){return new BigInt64Array(e)}function b(e){return new BigInt64Array(e)}function g(...e){const t=e.reduce((s,i)=>s+i.length,0),o=new BigInt64Array(t);let n=0;for(const s of e)o.set(s,n),n+=s.length;return o}function h(e){return e.reduce((t,o,n)=>t+(BigInt(o)<<BigInt((e.length-1-n)*8)),BigInt(0))}function d(e,t){const o=[];for(let n=0;n<t;n++)o.push(e>>BigInt((t-1-n)*8)&0xffn);return new BigInt64Array(o)}function v(e){return Array(5).fill(BigInt(0)).map((t,o)=>h(e.subarray(o*8,(o+1)*8)))}function m(e,t){return e>>t|(e&(1n<<t)-1n)<<64n-t}function C(e,t){if(e.length!==t.length)return!1;for(let o=0;o<e.length;o++)if(e[o]!==t[o])return!1;return!0}function I(e){return e.reduce((t,o,n)=>(t[n]=BigInt(o),t),new BigInt64Array(e.length))}function H(e){return e.reduce((t,o,n)=>(t[n]=Number(o),t),new Uint8Array(e.length))}const E=e=>{if(typeof self<"u"&&(self.crypto||self.msCrypto)){const t=self.crypto||self.msCrypto,o=65536,n=new Uint8Array(e);for(let s=0;s<e;s+=o)t.getRandomValues(n.subarray(s,s+Math.min(e-s,o)));return n}else return require("crypto").randomBytes(e)},$=e=>Array.prototype.map.call(e,t=>t.toString(16).padStart(2,"0")).join(""),q=e=>Uint8Array.from(e.match(/.{1,2}/g)?.map(t=>parseInt(t,16))??[]);class D{static hash(t,o){const n=I(t),s=o?.variant??"Ascon-Hash",i=o?.length??32;z(s),M(i,s);const c=12,r=["Ascon-Hasha","Ascon-Xofa"].includes(s)?8:12,l=8,f=d(["Ascon-Hash","Ascon-Hasha"].includes(s)?256n:0n,4),a=v(g(w([0n,BigInt(l*8),BigInt(c),BigInt(c-r)]),f,b(32)));this.permutation(a,c);const u=g(n,w([0x80n]),b(l-n.length%l-1));for(let p=0;p<u.length-l;p+=l)a[0]^=h(u.slice(p,p+8)),this.permutation(a,r);const y=u.length-l;a[0]^=h(u.slice(y,y+8)),this.permutation(a,c);let A=new BigInt64Array;for(;A.length<i;)A=g(A,d(a[0],8)),this.permutation(a,r);return H(A.slice(0,i))}static encrypt(t,o,n,s){const i=I(t),c=I(o),r=I(n),l=s?.associatedData?I(s?.associatedData):void 0,f=s?.variant??"Ascon-128";x(f),P(i,c,f);let a=Array(5).fill(BigInt(0));const u=i.length*8,y=12,A=f==="Ascon-128a"?8:6,p=f==="Ascon-128a"?16:8;a=this.initialize(a,u,p,y,A,i,c),this.processAssociatedData(a,A,p,l);const T=this.processPlaintext(a,A,p,r),L=this.finalize(a,p,y,i);return H(g(T,L))}static decrypt(t,o,n,s){const i=I(t),c=I(o),r=I(n),l=s?.associatedData?I(s?.associatedData):void 0,f=s?.variant??"Ascon-128";if(x(f),P(i,c,f),n.length<16)throw new Error("Could not be decrypted. Ciphertext too short.");let a=Array(5).fill(BigInt(0));const u=i.length*8,y=12,A=f==="Ascon-128a"?8:6,p=f==="Ascon-128a"?16:8;a=this.initialize(a,u,p,y,A,i,c),this.processAssociatedData(a,A,p,l);const T=this.processCipherText(a,A,p,r.slice(0,-16)),L=this.finalize(a,p,y,i);if(!C(L,r.slice(-16)))throw new Error("Could not be decrypted. Tags don't match.");return H(T)}static initialize(t,o,n,s,i,c,r){const l=g(w([BigInt(o),BigInt(n*8),BigInt(s),BigInt(i),...new Array(20-c.length).fill(0n)]),c,r);t=t.map((a,u)=>v(l)[u]),this.permutation(t,s);const f=v(g(b(40-c.length),c));return t=t.map((a,u)=>a^f[u]),t}static processAssociatedData(t,o,n,s){if(s&&s.length>0){const i=n-s.length%n-1,c=g(s,w([0x80n]),b(Number(i)));for(let r=0;r<c.length;r+=Number(n))t[0]^=h(c.slice(r,r+8)),n===16&&(t[1]^=h(c.slice(r+8,r+16))),this.permutation(t,o)}t[4]^=1n}static processPlaintext(t,o,n,s){const i=s.length%n,c=g(s,w([0x80n]),b(n-i-1));let r=new BigInt64Array;for(let f=0;f<c.length-n;f+=n)n===8?(t[0]^=h(c.slice(f,f+8)),r=g(r,d(t[0],8))):n===16&&(t[0]^=h(c.slice(f,f+8)),t[1]^=h(c.slice(f+8,f+16)),r=g(r,d(t[0],8),d(t[1],8))),this.permutation(t,o);const l=c.length-n;return n===8?(t[0]^=h(c.slice(l,l+8)),r=g(r,d(t[0],8).slice(0,i))):n===16&&(t[0]^=h(c.slice(l,l+8)),t[1]^=h(c.slice(l+8,l+16)),r=g(r,d(t[0],8).slice(0,Math.min(8,i)),d(t[1],8).slice(0,Math.max(0,i-8)))),r}static processCipherText(t,o,n,s){const i=s.length%n,c=g(s,b(n-i));let r=new BigInt64Array;for(let f=0;f<c.length-n;f+=n){if(n===8){const a=h(c.slice(f,f+8));r=g(r,d(t[0]^a,8)),t[0]=a}else if(n===16){const a=h(c.slice(f,f+8)),u=h(c.slice(f+8,f+16));r=g(r,d(t[0]^a,8),d(t[1]^u,8)),t[0]=a,t[1]=u}this.permutation(t,o)}const l=c.length-n;if(n===8){const f=0x80n<<BigInt(n-i-1)*8n,a=0xffffffffffffffffn>>BigInt(i*8),u=h(c.slice(l,l+8));r=g(r,d(u^t[0],8).slice(0,i)),t[0]=u^t[0]&a^f}else if(n===16){const f=BigInt(i%8),a=0x80n<<(8n-f-1n)*8n,u=0xffffffffffffffffn>>f*8n,y=h(c.slice(l,l+8)),A=h(c.slice(l+8,l+16));r=g(r,g(d(t[0]^y,8),d(t[1]^A,8)).slice(0,i)),i<8?t[0]=y^t[0]&u^a:(t[0]=y,t[1]=A^t[1]&u^a)}return r}static finalize(t,o,n,s){const i=o;t[Math.floor(i/8)+0]^=h(s.slice(0,8)),t[Math.floor(i/8)+1]^=h(s.slice(8,16));const c=g(s,b(24-s.length));return t[Math.floor(i/8)+2]^=h(c.slice(16)),this.permutation(t,n),t[3]^=h(s.slice(-16,-8)),t[4]^=h(s.slice(-8)),g(d(t[3],8),d(t[4],8))}static permutation(t,o=1){for(let n=12-o;n<12;n++){t[2]^=0xf0n-BigInt(n)*0x10n+BigInt(n)*0x1n,t[0]^=t[4],t[4]^=t[3],t[2]^=t[1];const s=[];for(let i=0;i<5;i++)s.push((t[i]^0xffffffffffffffffn)&t[(i+1)%5]);for(let i=0;i<5;i++)t[i]^=s[(i+1)%5];t[1]^=t[0],t[0]^=t[4],t[3]^=t[2],t[2]^=0xffffffffffffffffn,t[0]^=m(t[0],19n)^m(t[0],28n),t[1]^=m(t[1],61n)^m(t[1],39n),t[2]^=m(t[2],1n)^m(t[2],6n),t[3]^=m(t[3],10n)^m(t[3],17n),t[4]^=m(t[4],7n)^m(t[4],41n)}}}B.Ascon=D,B.fromHex=q,B.randomBytes=E,B.toHex=$,Object.defineProperty(B,Symbol.toStringTag,{value:"Module"})});
//# sourceMappingURL=ascon-js.umd.js.map
